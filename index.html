<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Interactive Color Theory Lab — p5.js</title>
<script src="https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/p5.min.js"></script>
<style>
  :root{
    --bg:#0b0e14; --card:#101826; --muted:#9fb0c6; --accent:#00d4ff; --stroke:#223048;
  }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(1200px 600px at 10% -10%, #14223b 0%, transparent 60%), var(--bg);color:#e8eef7;font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial}
  header{padding:22px 20px 10px; text-align:center}
  h1{margin:0;font-size:clamp(24px,3.4vw,36px);background:linear-gradient(90deg,#00d4ff,#9a6bff);-webkit-background-clip:text;background-clip:text;color:transparent}
  .sub{color:var(--muted)}
  .wrap{max-width:1200px;margin:0 auto;padding:16px 20px 36px;}
  .panel{background:linear-gradient(180deg,#101826, #0f1724);border:1px solid var(--stroke);border-radius:14px;box-shadow:0 12px 40px rgba(0,0,0,.45);padding:16px}
  .grid{display:grid;gap:16px;grid-template-columns:1.2fr 1fr}
  .controls{display:grid;gap:10px;grid-template-columns:repeat(2,minmax(0,1fr))}
  label{font-size:13px;color:#cfe0ff}
  select,input[type="range"],button{width:100%;background:#0e1522;border:1px solid var(--stroke);color:#e8eef7;padding:10px;border-radius:10px}
  button{cursor:pointer}
  .row{display:grid;gap:12px;grid-template-columns:repeat(4,minmax(0,1fr))}
  .swatch{height:56px;border-radius:12px;border:1px solid var(--stroke);box-shadow:inset 0 -24px 48px rgba(0,0,0,.25)}
  .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px;font-size:12px;color:var(--muted)}
  .area{display:grid;gap:16px;grid-template-columns:1fr 1fr}
  .card{background:#0e1624;border:1px solid var(--stroke);border-radius:14px;padding:10px;}
  .card h3{margin:6px 6px 10px;font-size:14px;color:#d7e7ff}
  canvas{display:block;width:100% !important;height:auto !important;border-radius:12px;border:1px solid var(--stroke)}
  .tip{margin-top:10px;color:var(--muted);font-size:13px}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;background:#0e1522;border:1px solid var(--stroke);padding:.1em .45em;border-radius:6px}
  .footer{margin-top:18px;display:flex;gap:10px;flex-wrap:wrap}
</style>
</head>
<body>
  <header>
    <h1>Interactive Color Theory Lab</h1>
    <div class="sub">Drag the wheel, explore harmony guides, and apply color effects to an image.</div>
  </header>

  <div class="wrap">
    <div class="grid">
      <div class="panel">
        <div id="wheel-container"></div>
        <div class="legend">
          <div><span class="kbd">Drag</span> handle to set base hue</div>
          <div>• Harmony lines show relationships</div>
          <div>• Click swatches to copy hex</div>
        </div>
        <div id="palette" class="row" style="margin-top:10px"></div>
      </div>

      <div class="panel">
        <div class="controls">
          <div>
            <label>Harmony</label>
            <select id="harmony">
              <option value="mono">Monochromatic</option>
              <option value="complementary">Complementary</option>
              <option value="split">Split Complementary</option>
              <option value="analogous">Analogous</option>
              <option value="triad">Triadic</option>
              <option value="tetradRect">Tetradic (Rectangle)</option>
              <option value="tetradSquare">Tetradic (Square)</option>
            </select>
          </div>
          <div>
            <label>Segments on Wheel</label>
            <input id="segments" type="range" min="24" max="180" step="6" value="90" />
          </div>
          <div>
            <label>Hue Rotate (°)</label>
            <input id="hueRot" type="range" min="-180" max="180" value="0" />
          </div>
          <div>
            <label>Saturation</label>
            <input id="sat" type="range" min="0" max="200" value="100" />
          </div>
          <div>
            <label>Brightness</label>
            <input id="bri" type="range" min="0" max="200" value="100" />
          </div>
          <div>
            <label>Contrast</label>
            <input id="con" type="range" min="50" max="200" value="100" />
          </div>
          <div>
            <label>Duotone: Shadow → Highlight</label>
            <div style="display:flex; gap:8px">
              <input type="color" id="duoA" value="#1a1a2e" title="Shadow" />
              <input type="color" id="duoB" value="#ff7a18" title="Highlight" />
              <button id="useHarmony">Use harmony pair</button>
            </div>
          </div>
          <div>
            <label>&nbsp;</label>
            <div style="display:flex;gap:8px;align-items:center">
              <button id="toggleDuotone">Toggle Duotone</button>
              <button id="resetFX">Reset FX</button>
              <label style="display:flex;gap:6px;align-items:center;margin-left:8px"><input type="checkbox" id="useGL"> Use WebGL shaders</label>
            </div>
          </div>
        </div>

        <div class="area" style="margin-top:14px">

        <div class="area" style="margin-top:14px">
          <div class="card">
            <h3>Original</h3>
            <div id="orig-c"></div>
          </div>
          <div class="card">
            <h3>Processed</h3>
            <div id="proc-c"></div>
          </div>
        </div>

        <div class="footer">
          <input type="file" id="file" accept="image/png, image/jpeg" />
          <button id="download">Download Processed PNG</button>
          <button id="sample">Load Sample Gradient</button>
        </div>
        <div class="tip">Tip: choose a PNG/JPG. The right canvas updates live as you tweak effects. For performance, large images are scaled down to fit the canvas.</div>
      </div>
    </div>
  </div>

<script>
/**********************
 * Color Theory Engine *
 **********************/
const SCHEMES = {
  mono:      [0, 0, 0, 0],
  complementary: [0, 180, 0, 0],
  split:     [0, 150, 210, 0],
  analogous: [-30, 0, 30, 0],
  triad:     [0, 120, 240, 0],
  tetradRect:[0, 60, 180, 240],
  tetradSquare:[0, 90, 180, 270],
};

function hslToRgb(h, s, l){
  s/=100; l/=100; const k=n=>(n+h/30)%12, a=s*Math.min(l,1-l);
  const f=n=>l-a*Math.max(-1,Math.min(k(n)-3,Math.min(9-k(n),1)));
  return [Math.round(255*f(0)), Math.round(255*f(8)), Math.round(255*f(4))];
}
function rgbToHsl(r,g,b){
  r/=255; g/=255; b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b); let h,s,l=(max+min)/2;
  if(max===min){h=s=0;} else { const d=max-min; s=l>0.5? d/(2-max-min): d/(max+min);
    switch(max){ case r:h=(g-b)/d+(g<b?6:0);break; case g:h=(b-r)/d+2;break; case b:h=(r-g)/d+4;break; }
    h*=60; s*=100; l*=100;
  }
  return [h,s,l];
}
const toHex = (r,g,b)=>"#"+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('').toUpperCase();

/****************
 * p5 Sketch(es) *
 ****************/
let wheelSketch, imgOrigSketch, imgProcSketch;
let baseHue = 200;    // starting hue
let segments = 90;    // wheel detail
let harmony = 'triad';
let palette = [];
let radius, cx, cy;   // for wheel
let dragging = false;
let procImg, origImg; // p5.Image refs
let controls = {};
let duotoneOn = false;

function computePalette(){
  const angles = SCHEMES[harmony].filter(a=>!isNaN(a));
  const hs = angles.map(a => (baseHue + a + 360) % 360);
  // default sat/lig for swatches
  return hs.map(h => toHex(...hslToRgb(h, 80, 55)));
}

function updatePaletteUI(){
  const cont = document.getElementById('palette');
  cont.innerHTML = '';
  palette = computePalette();
  palette.forEach(hex=>{
    const d = document.createElement('div');
    d.className='swatch';
    d.style.background = hex;
    d.title = hex;
    d.onclick = async ()=>{ await navigator.clipboard.writeText(hex); d.style.outline='2px solid var(--accent)'; setTimeout(()=>d.style.outline='none', 600); };
    cont.appendChild(d);
  });
}

// ========== Wheel ==========
const wheelCanvas = new p5(p => {
  let W=560, H=560;
  p.setup = () => {
    const holder = document.getElementById('wheel-container');
    const c = p.createCanvas(W, H);
    c.parent(holder);
    p.pixelDensity(1);
    radius = Math.min(W, H)*0.46; cx=W/2; cy=H/2;
    drawWheel();
  };

  function drawWheel(){
    p.clear();
    // draw conic using many arcs
    p.noStroke();
    for(let i=0;i<segments;i++){
      const a0 = p.TWO_PI * (i/segments);
      const a1 = p.TWO_PI * ((i+1)/segments);
      const deg = (360 * i/segments);
      const col = hslToRgb(deg, 100, 50);
      p.fill(...col);
      p.arc(cx, cy, radius*2, radius*2, a0, a1, p.PIE);
    }
    // inner hole
    p.fill(16,22,34); p.circle(cx, cy, radius*0.52);

    // harmony lines/points
    const angles = SCHEMES[harmony].filter(a=>!isNaN(a));
    p.stroke(0,0,0,120); p.strokeWeight(3);
    const points = angles.map(a=>{
      const d = (baseHue + a) % 360; const rad = p.radians(d-90);
      return {x: cx + Math.cos(rad)*radius*0.9, y: cy + Math.sin(rad)*radius*0.9, d};
    });
    p.noFill();
    p.beginShape(); points.forEach(pt=>p.vertex(pt.x, pt.y)); if(points.length>2) p.endShape(p.CLOSE); else p.endShape();
    p.stroke(0,212,255,220); p.strokeWeight(2);
    p.beginShape(); points.forEach(pt=>p.vertex(pt.x, pt.y)); if(points.length>2) p.endShape(p.CLOSE); else p.endShape();

    // draggable base handle (at baseHue)
    const rad = p.radians(baseHue-90);
    const hx = cx + Math.cos(rad)*radius*0.9;
    const hy = cy + Math.sin(rad)*radius*0.9;
    p.noStroke(); p.fill(255); p.circle(hx, hy, 14); p.fill(0); p.circle(hx, hy, 6);

    // label
    p.noStroke(); p.fill(232,238,247); p.textAlign(p.CENTER, p.CENTER); p.textSize(14);
    p.text(`Hue: ${Math.round(baseHue)}°  •  Harmony: ${harmony}`, cx, H-18);
  }

  function setHueFromMouse(){
    const dx = p.mouseX - cx; const dy = p.mouseY - cy;
    const angle = Math.atan2(dy, dx); // radians
    baseHue = (p.degrees(angle) + 90 + 360) % 360;
  }

  p.mousePressed = () => {
    const d = p.dist(p.mouseX, p.mouseY, cx, cy);
    if (d > radius*0.7 && d < radius*1.05){ dragging = true; setHueFromMouse(); updatePaletteUI(); drawWheel(); scheduleProcess(); }
  };
  p.mouseDragged = () => { if(dragging){ setHueFromMouse(); updatePaletteUI(); drawWheel(); scheduleProcess(); } };
  p.mouseReleased = () => { dragging=false; };

  p.windowResized = () => { /* keep fixed size for clarity */ };

  // public API
  wheelSketch = {
    redraw: () => { drawWheel(); }
  };
});

// ========== Image canvases ==========
const origCanvas = new p5(p => {
  let W=520,H=360; p.setup = ()=>{ const c=p.createCanvas(W,H); c.parent(document.getElementById('orig-c')); p.background(20); }; imgOrigSketch=p;});
const procCanvas = new p5(p => {
  let W=520,H=360; let sh; p.setup = ()=>{ const c=p.createCanvas(W,H, p.WEBGL); c.parent(document.getElementById('proc-c')); p.background(20); sh = p.createShader(vertSrc, fragSrc); }; imgProcSketch=p;});

/*******************
 * Image Processing *
 *******************/
let scheduleId = null;
function scheduleProcess(){ clearTimeout(scheduleId); scheduleId = setTimeout(applyEffects, 40); }

function loadFromFile(file){
  const reader = new FileReader();
  reader.onload = e => {
    const img = new Image(); img.onload = () => {
      const g = new p5.Image(img.width, img.height);
      g.canvas = img; // create from HTMLImageElement
    };
  };
}

function setOrig(img){
  origImg = img;
  const p = imgOrigSketch, w = p.width, h = p.height;
  p.background(16);
  const scale = Math.min(w/img.width, h/img.height);
  const dw = img.width*scale, dh = img.height*scale;
  p.image(img, (w-dw)/2, (h-dh)/2, dw, dh);
}

function applyEffects(){
  if(!origImg) return;
  const p = imgProcSketch;
  const w=p.width, h=p.height; p.clear();
  if(document.getElementById('useGL').checked){
    // WEBGL shader path
    const hueRot = Number(document.getElementById('hueRot').value) * Math.PI/180.0;
    const satMul = Number(document.getElementById('sat').value)/100.0;
    const briMul = Number(document.getElementById('bri').value)/100.0;
    const conMul = Number(document.getElementById('con').value)/100.0;
    const duoA = document.getElementById('duoA').value; const duoB = document.getElementById('duoB').value;
    const [aR,aG,aB] = hexToRgb(duoA).map(v=>v/255); const [bR,bG,bB] = hexToRgb(duoB).map(v=>v/255);
    p.shader(p._renderer._pInst? p._renderer._pInst.createShader: p.createShader); // noop placeholder
    const sh = p._shader || p.createShader(vertSrc, fragSrc);
    p.shader(sh);
    sh.setUniform('tex0', origImg);
    sh.setUniform('u_resolution', [w,h]);
    sh.setUniform('u_hue', hueRot);
    sh.setUniform('u_sat', satMul);
    sh.setUniform('u_bri', briMul);
    sh.setUniform('u_con', conMul);
    sh.setUniform('u_duotone', duotoneOn?1:0);
    sh.setUniform('u_duoA', [aR,aG,aB]);
    sh.setUniform('u_duoB', [bR,bG,bB]);
    p.noStroke(); p.rect(-w/2, -h/2, w, h);
  } else {
    // CPU fallback (original path)
    const scale = Math.min(w/origImg.width, h/origImg.height);
    const dw = Math.max(1, Math.floor(origImg.width*scale));
    const dh = Math.max(1, Math.floor(origImg.height*scale));
    const tmp = p.createImage(dw, dh); tmp.copy(origImg, 0,0, origImg.width, origImg.height, 0,0,dw,dh);
    tmp.loadPixels();
    const hueRot = Number(document.getElementById('hueRot').value);
    const satMul = Number(document.getElementById('sat').value)/100;
    const briMul = Number(document.getElementById('bri').value)/100;
    const conMul = Number(document.getElementById('con').value)/100;
    const duoA = document.getElementById('duoA').value; const duoB = document.getElementById('duoB').value;
    const [aR,aG,aB] = hexToRgb(duoA); const [bR,bG,bB] = hexToRgb(duoB);
    for(let i=0;i<tmp.pixels.length;i+=4){
      let r=tmp.pixels[i], g=tmp.pixels[i+1], b=tmp.pixels[i+2];
      let [h,s,l] = rgbToHsl(r,g,b);
      h = (h + hueRot + 360) % 360; s = Math.min(100, Math.max(0, s*satMul)); l = Math.min(100, Math.max(0, l*briMul));
      [r,g,b] = hslToRgb(h,s,l);
      r = clamp((r-128)*conMul + 128); g = clamp((g-128)*conMul + 128); b = clamp((b-128)*conMul + 128);
      if(duotoneOn){ const Y=(0.2126*r+0.7152*g+0.0722*b)/255; r=Math.round(aR*(1-Y)+bR*Y); g=Math.round(aG*(1-Y)+bG*Y); b=Math.round(aB*(1-Y)+bB*Y);} 
      tmp.pixels[i]=r; tmp.pixels[i+1]=g; tmp.pixels[i+2]=b;
    }
    tmp.updatePixels(); p.image(tmp, -dw/2, -dh/2);
  }
}

    tmp.pixels[i]=r; tmp.pixels[i+1]=g; tmp.pixels[i+2]=b; // keep alpha
  }
  tmp.updatePixels();
  p.image(tmp, (w-dw)/2, (h-dh)/2);
}

function clamp(v){ return Math.max(0, Math.min(255, v)); }
function hexToRgb(hex){ const n=parseInt(hex.slice(1),16); return [(n>>16)&255,(n>>8)&255,n&255]; }

/*************
 * UI Wiring *
 *************/
function initUI(){
  // controls
  controls.harmony = document.getElementById('harmony');
  controls.harmony.value = harmony;
  controls.harmony.onchange = () => { harmony = controls.harmony.value; wheelSketch.redraw(); updatePaletteUI(); };

  document.getElementById('segments').oninput = (e)=>{ segments = Number(e.target.value); wheelSketch.redraw(); };
  ['hueRot','sat','bri','con','useGL'].forEach(id=> document.getElementById(id).oninput = scheduleProcess);

  document.getElementById('toggleDuotone').onclick = ()=>{ duotoneOn=!duotoneOn; scheduleProcess(); };
  document.getElementById('useHarmony').onclick = ()=>{
    updatePaletteUI();
    const hexA = palette[0] || '#1a1a2e';
    const hexB = palette[1] || '#ff7a18';
    document.getElementById('duoA').value = hexA; document.getElementById('duoB').value = hexB; scheduleProcess();
  };
  document.getElementById('duoA').oninput = scheduleProcess;
  document.getElementById('duoB').oninput = scheduleProcess;

  document.getElementById('resetFX').onclick = ()=>{
    ['hueRot','sat','bri','con'].forEach(id=> document.getElementById(id).value = ({hueRot:0,sat:100,bri:100,con:100}[id]));
    duotoneOn=false; document.getElementById('useGL').checked=false; scheduleProcess();
  };

  document.getElementById('file').addEventListener('change', (e)=>{
    const f=e.target.files[0]; if(!f) return; const url=URL.createObjectURL(f);
    const img = new Image(); img.onload = ()=>{
      const tmp = document.createElement('canvas'); tmp.width=img.width; tmp.height=img.height; const ctx=tmp.getContext('2d'); ctx.drawImage(img,0,0);
      const pimg = imgProcSketch.createImage(img.width, img.height); const data=ctx.getImageData(0,0,img.width,img.height);
      pimg.loadPixels(); pimg.pixels.set(data.data); pimg.updatePixels();
      origImg = pimg; setOrig(origImg); scheduleProcess(); URL.revokeObjectURL(url);
    }; img.src = url;
  });
  document.getElementById('download').onclick = ()=>{
    const link = document.createElement('a'); link.download = 'processed.png'; link.href = imgProcSketch.canvas.toDataURL('image/png'); link.click();
  };
  document.getElementById('sample').onclick = ()=>{
    const w=1024,h=640; const pimg = imgProcSketch.createImage(w,h); pimg.loadPixels();
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const t = x/(w-1); const hhh = (baseHue + t*180) % 360; const [r,g,b]=hslToRgb(hhh, 80, 50);
        const idx=(y*w+x)*4; pimg.pixels[idx]=r; pimg.pixels[idx+1]=g; pimg.pixels[idx+2]=b; pimg.pixels[idx+3]=255;
      }
    }
    pimg.updatePixels(); origImg=pimg; setOrig(origImg); scheduleProcess();
  };

  updatePaletteUI();
}

initUI();


// ====== Shaders (inline to avoid CORS on GitHub Pages) ======
const vertSrc = `
  precision mediump float;
  attribute vec3 aPosition;
  attribute vec2 aTexCoord;
  varying vec2 vTex;
  void main(){ vTex = aTexCoord; gl_Position = vec4(aPosition,1.0);} 
`;
const fragSrc = `
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D tex0;
  uniform vec2 u_resolution;
  uniform float u_hue;  // radians
  uniform float u_sat;  // 1.0 = neutral
  uniform float u_bri;  // 1.0 = neutral
  uniform float u_con;  // 1.0 = neutral
  uniform int u_duotone;
  uniform vec3 u_duoA;
  uniform vec3 u_duoB;

  vec3 rgb2hsl(vec3 c){
    float r=c.r, g=c.g, b=c.b;
    float maxc=max(max(r,g),b); float minc=min(min(r,g),b); float h=0.0; float s=0.0; float l=(maxc+minc)*0.5;
    if(maxc!=minc){
      float d=maxc-minc; s = l>0.5 ? d/(2.0-maxc-minc) : d/(maxc+minc);
      if(maxc==r) h=(g-b)/d + (g<b ? 6.0:0.0);
      else if(maxc==g) h=(b-r)/d + 2.0; else h=(r-g)/d + 4.0; h/=6.0; }
    return vec3(h,s,l);
  }
  float hue2rgb(float p, float q, float t){ if(t<0.0) t+=1.0; if(t>1.0) t-=1.0; if(t<1.0/6.0) return p + (q-p)*6.0*t; if(t<1.0/2.0) return q; if(t<2.0/3.0) return p + (q-p)*(2.0/3.0 - t)*6.0; return p; }
  vec3 hsl2rgb(vec3 c){ float h=c.x, s=c.y, l=c.z; float r,g,b; if(s==0.0){ r=g=b=l; } else { float q = l<0.5 ? l*(1.0+s) : l + s - l*s; float p = 2.0*l - q; r = hue2rgb(p,q,h+1.0/3.0); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1.0/3.0);} return vec3(r,g,b);} 

  void main(){
    vec2 uv = vTex; vec4 c = texture2D(tex0, uv);
    vec3 hsl = rgb2hsl(c.rgb);
    hsl.x = mod(hsl.x + (u_hue/6.28318530718), 1.0); // hue rotate
    hsl.y = clamp(hsl.y * u_sat, 0.0, 1.0);
    hsl.z = clamp(hsl.z * u_bri, 0.0, 1.0);
    vec3 col = hsl2rgb(hsl);
    // contrast
    col = (col - 0.5) * u_con + 0.5;
    col = clamp(col, 0.0, 1.0);
    if(u_duotone==1){
      float Y = dot(col, vec3(0.2126,0.7152,0.0722));
      col = mix(u_duoA, u_duoB, Y);
    }
    gl_FragColor = vec4(col, 1.0);
  }
`;

</script>
</body>
</html>
